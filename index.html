<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI Battle Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
            padding: 30px;
            max-width: 900px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #2d3436;
            margin-bottom: 25px;
            font-size: 2.2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        h1::after {
            content: '';
            display: block;
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            margin: 10px auto;
            border-radius: 2px;
        }
        
        .header-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .control-panel {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102,126,234,0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102,126,234,0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .match-info {
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 4px solid #2d3436;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            cursor: default;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .square.light {
            background-color: #f0d9b5;
        }
        
        .square.dark {
            background-color: #b58863;
        }
        
        .square.last-move {
            background-color: rgba(255, 255, 100, 0.6) !important;
        }
        
        .square:hover {
            filter: brightness(1.1);
        }
        
        .coord {
            position: absolute;
            font-size: 0.7rem;
            font-weight: bold;
            color: rgba(0,0,0,0.7);
        }
        
        .coord.file {
            bottom: 2px;
            right: 4px;
        }
        
        .coord.rank {
            top: 2px;
            left: 4px;
        }
        
        .square.dark .coord {
            color: rgba(255,255,255,0.9);
        }
        
        .status-panel {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .status {
            font-size: 1.3rem;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        .move-time {
            font-size: 1rem;
            color: #636e72;
            text-align: center;
            margin-top: 5px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        
        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .stat-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(102,126,234,0.2);
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2d3436;
        }
        
        .ai-info {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .ai-box {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 200px;
        }
        
        .ai-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #2d3436;
            margin-bottom: 8px;
        }
        
        .ai-stats {
            font-size: 0.9rem;
            color: #666;
        }
        
        .captured-pieces {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .captured-section {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .captured-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .captured-container {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
            min-height: 30px;
            min-width: 100px;
        }
        
        .captured-piece {
            font-size: 1.5rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.6rem;
            }
            
            .square {
                font-size: 1.8rem;
            }
            
            .stat-value {
                font-size: 1.4rem;
            }
            
            .control-panel {
                justify-content: center;
            }
            
            .header-info {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî Chess AI Battle Arena ‚ôö</h1>
        
        <div class="header-info">
            <div class="match-info">
                Match #<span id="matchNumber">1</span>
            </div>
            <div class="control-panel">
                <button onclick="togglePause()" id="pauseBtn">‚è∏Ô∏è Pause</button>
                <button onclick="resetStats()">üîÑ Reset Stats</button>
                <button onclick="newGame()">üÜï New Game</button>
            </div>
        </div>
        
        <div class="status-panel">
            <div class="status" id="status">Initializing AI Battle...</div>
            <div class="move-time" id="moveTime"></div>
        </div>
        
        <div class="ai-info">
            <div class="ai-box" style="border-left: 5px solid #667eea;">
                <div class="ai-name">ü§ñ White AI</div>
                <div class="ai-stats">
                    Wins: <span id="whiteWinsCount">0</span> | 
                    Learning: <span id="whiteLearning">0%</span>
                </div>
            </div>
            <div class="ai-box" style="border-left: 5px solid #2d3436;">
                <div class="ai-name">ü§ñ Black AI</div>
                <div class="ai-stats">
                    Wins: <span id="blackWinsCount">0</span> | 
                    Learning: <span id="blackLearning">0%</span>
                </div>
            </div>
        </div>
        
        <div class="board-container">
            <div class="chessboard" id="chessboard"></div>
        </div>
        
        <div class="captured-pieces">
            <div class="captured-section">
                <div class="captured-label">White Captured:</div>
                <div class="captured-container" id="capturedWhite"></div>
            </div>
            <div class="captured-section">
                <div class="captured-label">Black Captured:</div>
                <div class="captured-container" id="capturedBlack"></div>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">Total Matches</div>
                <div class="stat-value" id="totalMatches">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">White AI Wins</div>
                <div class="stat-value" id="whiteWins">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Black AI Wins</div>
                <div class="stat-value" id="blackWins">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Draws</div>
                <div class="stat-value" id="draws">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Current Move</div>
                <div class="stat-value" id="moveCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Match Time</div>
                <div class="stat-value" id="matchTime">0s</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Total Time</div>
                <div class="stat-value" id="totalTime">0s</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">AI Level</div>
                <div class="stat-value" id="aiLevel">3</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // LOCAL STORAGE MANAGER - SIMPLIFIED
        // ============================================
        
        class StorageManager {
            static save(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.error('Error saving:', e);
                    return false;
                }
            }
            
            static load(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    console.error('Error loading:', e);
                    return null;
                }
            }
        }
        
        // ============================================
        // SIMPLIFIED GAME STATISTICS
        // ============================================
        
        const gameStats = {
            totalMatches: 0,
            whiteWins: 0,
            blackWins: 0,
            draws: 0,
            totalTime: 0,
            aiLevel: 3
        };
        
        function loadStats() {
            const saved = StorageManager.load('chessStats');
            if (saved) {
                Object.assign(gameStats, saved);
                console.log('Loaded stats:', gameStats);
            }
        }
        
        function saveStats() {
            StorageManager.save('chessStats', gameStats);
        }
        
        // ============================================
        // SIMPLIFIED CHESS ENGINE
        // ============================================
        
        class ChessEngine {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.board = [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
                this.currentPlayer = 'white';
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
            }
            
            getPieceColor(piece) {
                if (piece === ' ') return null;
                return piece === piece.toUpperCase() ? 'white' : 'black';
            }
            
            isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            getAllMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (this.getPieceColor(piece) === color) {
                            const pieceMoves = this.getPieceMoves(row, col);
                            moves.push(...pieceMoves);
                        }
                    }
                }
                return moves;
            }
            
            getPieceMoves(row, col) {
                const piece = this.board[row][col].toLowerCase();
                const color = this.getPieceColor(this.board[row][col]);
                
                if (!color) return [];
                
                let moves = [];
                
                switch(piece) {
                    case 'p': moves = this.getPawnMoves(row, col, color); break;
                    case 'n': moves = this.getKnightMoves(row, col, color); break;
                    case 'b': moves = this.getBishopMoves(row, col, color); break;
                    case 'r': moves = this.getRookMoves(row, col, color); break;
                    case 'q': moves = this.getQueenMoves(row, col, color); break;
                    case 'k': moves = this.getKingMoves(row, col, color); break;
                }
                
                // Filter moves that would leave king in check
                return moves.filter(move => !this.wouldBeInCheck(move, color));
            }
            
            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                // Move forward
                if (this.isValidSquare(row + direction, col) && 
                    this.board[row + direction][col] === ' ') {
                    moves.push({from: [row, col], to: [row + direction, col]});
                    
                    // Double move from start position
                    if (row === startRow && this.board[row + 2*direction][col] === ' ') {
                        moves.push({from: [row, col], to: [row + 2*direction, col]});
                    }
                }
                
                // Captures
                for (let dc of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target !== ' ' && this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            getKnightMoves(row, col, color) {
                const moves = [];
                const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target === ' ' || this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            getBishopMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, [[-1,-1],[-1,1],[1,-1],[1,1]]);
            }
            
            getRookMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, [[-1,0],[1,0],[0,-1],[0,1]]);
            }
            
            getQueenMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, 
                    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]);
            }
            
            getSlidingMoves(row, col, color, directions) {
                const moves = [];
                
                for (let [dr, dc] of directions) {
                    let newRow = row + dr;
                    let newCol = col + dc;
                    
                    while (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        
                        if (target === ' ') {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        } else {
                            if (this.getPieceColor(target) !== color) {
                                moves.push({from: [row, col], to: [newRow, newCol]});
                            }
                            break;
                        }
                        
                        newRow += dr;
                        newCol += dc;
                    }
                }
                
                return moves;
            }
            
            getKingMoves(row, col, color) {
                const moves = [];
                const offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target === ' ' || this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            wouldBeInCheck(move, color) {
                // Simulate move
                const tempBoard = this.board.map(row => [...row]);
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                this.board[toRow][toCol] = this.board[fromRow][fromCol];
                this.board[fromRow][fromCol] = ' ';
                
                const inCheck = this.isInCheck(color);
                
                // Restore board
                this.board = tempBoard;
                return inCheck;
            }
            
            isInCheck(color) {
                // Find king position
                let kingPos = null;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece.toLowerCase() === 'k' && this.getPieceColor(piece) === color) {
                            kingPos = [row, col];
                            break;
                        }
                    }
                    if (kingPos) break;
                }
                
                if (!kingPos) return false;
                
                // Check if any opponent piece can attack the king
                const opponentColor = color === 'white' ? 'black' : 'white';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (this.getPieceColor(piece) === opponentColor) {
                            const moves = this.getRawMoves(row, col);
                            for (let move of moves) {
                                if (move.to[0] === kingPos[0] && move.to[1] === kingPos[1]) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            getRawMoves(row, col) {
                const piece = this.board[row][col].toLowerCase();
                const color = this.getPieceColor(this.board[row][col]);
                
                if (!color) return [];
                
                switch(piece) {
                    case 'p': return this.getPawnMoves(row, col, color);
                    case 'n': return this.getKnightMoves(row, col, color);
                    case 'b': return this.getBishopMoves(row, col, color);
                    case 'r': return this.getRookMoves(row, col, color);
                    case 'q': return this.getQueenMoves(row, col, color);
                    case 'k': return this.getKingMoves(row, col, color);
                    default: return [];
                }
            }
            
            makeMove(move) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                const capturedPiece = this.board[toRow][toCol];
                const movingPiece = this.board[fromRow][fromCol];
                
                // Record captured piece
                if (capturedPiece !== ' ') {
                    const capturedColor = this.getPieceColor(capturedPiece);
                    const oppositeColor = capturedColor === 'white' ? 'black' : 'white';
                    this.capturedPieces[oppositeColor].push(capturedPiece);
                }
                
                // Make the move
                this.board[toRow][toCol] = movingPiece;
                this.board[fromRow][fromCol] = ' ';
                
                // Pawn promotion
                if (movingPiece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                    this.board[toRow][toCol] = this.currentPlayer === 'white' ? 'Q' : 'q';
                }
                
                // Update game state
                if (capturedPiece !== ' ' || movingPiece.toLowerCase() === 'p') {
                    this.halfMoveClock = 0;
                } else {
                    this.halfMoveClock++;
                }
                
                if (this.currentPlayer === 'black') {
                    this.fullMoveNumber++;
                }
                
                // Switch player
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                return true;
            }
            
            isCheckmate() {
                if (!this.isInCheck(this.currentPlayer)) return false;
                return this.getAllMoves(this.currentPlayer).length === 0;
            }
            
            isStalemate() {
                if (this.isInCheck(this.currentPlayer)) return false;
                return this.getAllMoves(this.currentPlayer).length === 0;
            }
            
            isDraw() {
                // 50-move rule
                if (this.halfMoveClock >= 50) return true;
                
                // Insufficient material
                const pieces = [];
                for (let row of this.board) {
                    for (let piece of row) {
                        if (piece !== ' ' && piece.toLowerCase() !== 'k') {
                            pieces.push(piece.toLowerCase());
                        }
                    }
                }
                
                if (pieces.length === 0) return true;
                if (pieces.length === 1 && (pieces[0] === 'n' || pieces[0] === 'b')) return true;
                
                return false;
            }
            
            isGameOver() {
                return this.isCheckmate() || this.isStalemate() || this.isDraw();
            }
            
            getGameResult() {
                if (this.isCheckmate()) {
                    return this.currentPlayer === 'white' ? 'black' : 'white';
                }
                if (this.isStalemate() || this.isDraw()) {
                    return 'draw';
                }
                return null;
            }
        }
        
        // ============================================
        // SIMPLIFIED CHESS AI
        // ============================================
        
        class ChessAI {
            constructor(color) {
                this.color = color;
                this.depth = gameStats.aiLevel;
                this.experience = 0;
            }
            
            evaluatePosition(engine) {
                let score = 0;
                const pieceValues = {
                    'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000
                };
                
                // Material evaluation
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = engine.board[row][col];
                        if (piece !== ' ') {
                            const value = pieceValues[piece.toLowerCase()];
                            if (engine.getPieceColor(piece) === this.color) {
                                score += value;
                            } else {
                                score -= value;
                            }
                        }
                    }
                }
                
                // Mobility bonus
                const myMoves = engine.getAllMoves(this.color).length;
                const opponentColor = this.color === 'white' ? 'black' : 'white';
                const opponentMoves = engine.getAllMoves(opponentColor).length;
                score += (myMoves - opponentMoves) * 10;
                
                // Check penalty/bonus
                if (engine.isInCheck(this.color)) {
                    score -= 50;
                }
                if (engine.isInCheck(opponentColor)) {
                    score += 50;
                }
                
                return score;
            }
            
            minimax(engine, depth, isMaximizing, alpha = -Infinity, beta = Infinity) {
                if (depth === 0 || engine.isGameOver()) {
                    return { score: this.evaluatePosition(engine) };
                }
                
                const color = isMaximizing ? this.color : (this.color === 'white' ? 'black' : 'white');
                const moves = engine.getAllMoves(color);
                
                if (moves.length === 0) {
                    return { score: this.evaluatePosition(engine) };
                }
                
                // Shuffle moves for variety
                moves.sort(() => Math.random() - 0.5);
                
                if (isMaximizing) {
                    let bestScore = -Infinity;
                    let bestMove = moves[0];
                    
                    for (const move of moves) {
                        const engineCopy = this.cloneEngine(engine);
                        engineCopy.makeMove(move);
                        
                        const result = this.minimax(engineCopy, depth - 1, false, alpha, beta);
                        
                        if (result.score > bestScore) {
                            bestScore = result.score;
                            bestMove = move;
                        }
                        
                        alpha = Math.max(alpha, bestScore);
                        if (beta <= alpha) {
                            break; // Beta cutoff
                        }
                    }
                    
                    return { score: bestScore, move: bestMove };
                } else {
                    let bestScore = Infinity;
                    let bestMove = moves[0];
                    
                    for (const move of moves) {
                        const engineCopy = this.cloneEngine(engine);
                        engineCopy.makeMove(move);
                        
                        const result = this.minimax(engineCopy, depth - 1, true, alpha, beta);
                        
                        if (result.score < bestScore) {
                            bestScore = result.score;
                            bestMove = move;
                        }
                        
                        beta = Math.min(beta, bestScore);
                        if (beta <= alpha) {
                            break; // Alpha cutoff
                        }
                    }
                    
                    return { score: bestScore, move: bestMove };
                }
            }
            
            cloneEngine(engine) {
                const clone = new ChessEngine();
                clone.board = engine.board.map(row => [...row]);
                clone.currentPlayer = engine.currentPlayer;
                clone.capturedPieces = {
                    white: [...engine.capturedPieces.white],
                    black: [...engine.capturedPieces.black]
                };
                clone.halfMoveClock = engine.halfMoveClock;
                clone.fullMoveNumber = engine.fullMoveNumber;
                return clone;
            }
            
            getBestMove(engine) {
                if (engine.isGameOver()) return null;
                
                const startTime = Date.now();
                const result = this.minimax(engine, this.depth, true);
                const moveTime = Date.now() - startTime;
                
                console.log(`${this.color} AI move time: ${moveTime}ms, Score: ${result.score.toFixed(2)}`);
                
                this.experience++;
                return result.move;
            }
            
            getLearningProgress() {
                return Math.min(100, Math.floor((this.experience / 20) * 100));
            }
        }
        
        // ============================================
        // GAME STATE
        // ============================================
        
        let chessEngine = new ChessEngine();
        let whiteAI = new ChessAI('white');
        let blackAI = new ChessAI('black');
        let isPaused = false;
        let gameActive = true;
        let currentMoveCount = 0;
        let lastMove = null;
        let matchStartTime = Date.now();
        let moveStartTime = Date.now();
        
        // ============================================
        // DOM ELEMENTS
        // ============================================
        
        const chessboard = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const moveTimeElement = document.getElementById('moveTime');
        const moveCountElement = document.getElementById('moveCount');
        const matchTimeElement = document.getElementById('matchTime');
        const totalTimeElement = document.getElementById('totalTime');
        const totalMatchesElement = document.getElementById('totalMatches');
        const whiteWinsElement = document.getElementById('whiteWins');
        const blackWinsElement = document.getElementById('blackWins');
        const drawsElement = document.getElementById('draws');
        const aiLevelElement = document.getElementById('aiLevel');
        const whiteWinsCountElement = document.getElementById('whiteWinsCount');
        const blackWinsCountElement = document.getElementById('blackWinsCount');
        const whiteLearningElement = document.getElementById('whiteLearning');
        const blackLearningElement = document.getElementById('blackLearning');
        const matchNumberElement = document.getElementById('matchNumber');
        const capturedWhiteElement = document.getElementById('capturedWhite');
        const capturedBlackElement = document.getElementById('capturedBlack');
        const pauseBtn = document.getElementById('pauseBtn');
        
        // ============================================
        // DISPLAY FUNCTIONS
        // ============================================
        
        function updateStatsDisplay() {
            totalMatchesElement.textContent = gameStats.totalMatches;
            whiteWinsElement.textContent = gameStats.whiteWins;
            blackWinsElement.textContent = gameStats.blackWins;
            drawsElement.textContent = gameStats.draws;
            
            whiteWinsCountElement.textContent = gameStats.whiteWins;
            blackWinsCountElement.textContent = gameStats.blackWins;
            
            aiLevelElement.textContent = gameStats.aiLevel;
            
            whiteLearningElement.textContent = whiteAI.getLearningProgress() + '%';
            blackLearningElement.textContent = blackAI.getLearningProgress() + '%';
            
            matchNumberElement.textContent = gameStats.totalMatches + 1;
        }
        
        function updateTimeDisplay() {
            const matchElapsed = Math.floor((Date.now() - matchStartTime) / 1000);
            matchTimeElement.textContent = `${matchElapsed}s`;
            
            const totalSeconds = gameStats.totalTime + matchElapsed;
            if (totalSeconds < 60) {
                totalTimeElement.textContent = `${totalSeconds}s`;
            } else if (totalSeconds < 3600) {
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                totalTimeElement.textContent = `${minutes}m ${seconds}s`;
            } else {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                totalTimeElement.textContent = `${hours}h ${minutes}m`;
            }
        }
        
        function updateCapturedPieces() {
            capturedWhiteElement.innerHTML = chessEngine.capturedPieces.white
                .map(piece => `<span class="captured-piece">${getPieceSymbol(piece)}</span>`)
                .join('');
            
            capturedBlackElement.innerHTML = chessEngine.capturedPieces.black
                .map(piece => `<span class="captured-piece">${getPieceSymbol(piece)}</span>`)
                .join('');
        }
        
        function getPieceSymbol(piece) {
            const symbols = {
                'p': '‚ôü', 'n': '‚ôû', 'b': '‚ôù', 'r': '‚ôú', 'q': '‚ôõ', 'k': '‚ôö',
                'P': '‚ôô', 'N': '‚ôò', 'B': '‚ôó', 'R': '‚ôñ', 'Q': '‚ôï', 'K': '‚ôî'
            };
            return symbols[piece] || piece;
        }
        
        function renderBoard() {
            chessboard.innerHTML = '';
            
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    
                    // Highlight last move
                    if (lastMove && (
                        (lastMove.from[0] === row && lastMove.from[1] === col) ||
                        (lastMove.to[0] === row && lastMove.to[1] === col)
                    )) {
                        square.classList.add('last-move');
                    }
                    
                    // Add piece
                    const piece = chessEngine.board[row][col];
                    if (piece !== ' ') {
                        square.textContent = getPieceSymbol(piece);
                    }
                    
                    // Add coordinates
                    if (row === 7) {
                        const fileCoord = document.createElement('div');
                        fileCoord.className = 'coord file';
                        fileCoord.textContent = files[col];
                        square.appendChild(fileCoord);
                    }
                    
                    if (col === 0) {
                        const rankCoord = document.createElement('div');
                        rankCoord.className = 'coord rank';
                        rankCoord.textContent = 8 - row;
                        square.appendChild(rankCoord);
                    }
                    
                    chessboard.appendChild(square);
                }
            }
        }
        
        function updateStatus(message, color = '#667eea') {
            statusElement.textContent = message;
            statusElement.style.color = color;
        }
        
        // ============================================
        // GAME CONTROL FUNCTIONS
        // ============================================
        
        function togglePause() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            
            if (isPaused) {
                updateStatus('Game Paused', '#fdcb6e');
            } else {
                processAIMove();
            }
        }
        
        function newGame() {
            chessEngine.reset();
            gameActive = true;
            isPaused = false;
            currentMoveCount = 0;
            matchStartTime = Date.now();
            moveStartTime = Date.now();
            lastMove = null;
            
            pauseBtn.textContent = '‚è∏Ô∏è Pause';
            updateStatus('Starting new game...', '#667eea');
            renderBoard();
            updateCapturedPieces();
            updateStatsDisplay();
            
            setTimeout(processAIMove, 500);
        }
        
        function resetStats() {
            if (confirm('Are you sure you want to reset all statistics?')) {
                gameStats.totalMatches = 0;
                gameStats.whiteWins = 0;
                gameStats.blackWins = 0;
                gameStats.draws = 0;
                gameStats.totalTime = 0;
                saveStats();
                updateStatsDisplay();
                newGame();
            }
        }
        
        function endGame(result) {
            gameActive = false;
            const matchDuration = Math.floor((Date.now() - matchStartTime) / 1000);
            
            gameStats.totalMatches++;
            gameStats.totalTime += matchDuration;
            
            if (result === 'white') {
                gameStats.whiteWins++;
                updateStatus('üéâ White AI Wins!', '#00b894');
            } else if (result === 'black') {
                gameStats.blackWins++;
                updateStatus('üéâ Black AI Wins!', '#00b894');
            } else {
                gameStats.draws++;
                updateStatus('ü§ù Game Drawn!', '#636e72');
            }
            
            saveStats();
            updateStatsDisplay();
            
            setTimeout(() => {
                if (confirm(`Game Over! ${result === 'draw' ? 'Draw!' : result + ' wins!'}\nStart new game?`)) {
                    newGame();
                }
            }, 1500);
        }
        
        async function processAIMove() {
            if (!gameActive || isPaused) return;
            
            const moveStart = Date.now();
            let ai, opponentColor;
            
            if (chessEngine.currentPlayer === 'white') {
                ai = whiteAI;
                opponentColor = 'black';
                updateStatus('ü§ñ White AI Thinking...', '#667eea');
            } else {
                ai = blackAI;
                opponentColor = 'white';
                updateStatus('ü§ñ Black AI Thinking...', '#2d3436');
            }
            
            // Small delay for visual feedback
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const move = ai.getBestMove(chessEngine);
            
            if (move) {
                chessEngine.makeMove(move);
                lastMove = move;
                currentMoveCount++;
                
                const moveTime = Date.now() - moveStart;
                moveTimeElement.textContent = `Move time: ${moveTime}ms`;
                moveCountElement.textContent = currentMoveCount;
                
                renderBoard();
                updateCapturedPieces();
                
                if (chessEngine.isGameOver()) {
                    const result = chessEngine.getGameResult();
                    endGame(result);
                    return;
                }
                
                // Continue with next move after a short delay
                setTimeout(processAIMove, 300);
            }
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        function init() {
            console.log('Initializing Chess AI Battle Arena...');
            
            // Load saved stats
            loadStats();
            
            // Initial render
            renderBoard();
            updateStatsDisplay();
            updateTimeDisplay();
            
            // Start game
            setTimeout(() => {
                updateStatus('White AI Thinking...', '#667eea');
                processAIMove();
            }, 1000);
            
            // Update time display every second
            setInterval(updateTimeDisplay, 1000);
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
