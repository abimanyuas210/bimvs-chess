<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI Battle Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 20px;
            max-width: 800px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 3px solid #333;
            width: 100%;
            max-width: 480px;
            aspect-ratio: 1;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            cursor: default;
            transition: background-color 0.2s;
        }
        
        .square.light {
            background-color: #f0d9b5;
        }
        
        .square.dark {
            background-color: #b58863;
        }
        
        .square.last-move {
            background-color: rgba(255, 255, 0, 0.4) !important;
        }
        
        .status-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .status {
            font-size: 1.1rem;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-box {
            background: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #333;
        }
        
        .move-time {
            font-size: 0.9rem;
            color: #888;
            text-align: center;
            margin-top: 5px;
        }
        
        @media (max-width: 600px) {
            h1 {
                font-size: 1.3rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stat-value {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>♔ Chess AI Battle Arena ♚</h1>
        
        <div class="status-panel">
            <div class="status" id="status">Initializing...</div>
            <div class="move-time" id="moveTime"></div>
        </div>
        
        <div class="board-container">
            <div class="chessboard" id="chessboard"></div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">Total Matches</div>
                <div class="stat-value" id="totalMatches">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">WhiteAI Wins</div>
                <div class="stat-value" id="whiteWins">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">BlackAI Wins</div>
                <div class="stat-value" id="blackWins">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Draws</div>
                <div class="stat-value" id="draws">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Current Match</div>
                <div class="stat-value" id="matchTime">0s</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Total Runtime</div>
                <div class="stat-value" id="totalTime">0s</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CHESS ENGINE
        // ============================================
        
        class ChessEngine {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.moveHistory = [];
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
            }
            
            createInitialBoard() {
                return [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
            }
            
            isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            getPieceColor(piece) {
                if (piece === ' ') return null;
                return piece === piece.toUpperCase() ? 'white' : 'black';
            }
            
            getAllMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (this.getPieceColor(piece) === color) {
                            const pieceMoves = this.getPieceMoves(row, col);
                            moves.push(...pieceMoves);
                        }
                    }
                }
                return moves;
            }
            
            getPieceMoves(row, col) {
                const piece = this.board[row][col].toLowerCase();
                const color = this.getPieceColor(this.board[row][col]);
                
                if (!color) return [];
                
                let moves = [];
                
                switch(piece) {
                    case 'p': moves = this.getPawnMoves(row, col, color); break;
                    case 'n': moves = this.getKnightMoves(row, col, color); break;
                    case 'b': moves = this.getBishopMoves(row, col, color); break;
                    case 'r': moves = this.getRookMoves(row, col, color); break;
                    case 'q': moves = this.getQueenMoves(row, col, color); break;
                    case 'k': moves = this.getKingMoves(row, col, color); break;
                }
                
                return moves.filter(move => !this.wouldBeInCheck(move, color));
            }
            
            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                if (this.isValidSquare(row + direction, col) && 
                    this.board[row + direction][col] === ' ') {
                    moves.push({from: [row, col], to: [row + direction, col]});
                    
                    if (row === startRow && this.board[row + 2*direction][col] === ' ') {
                        moves.push({from: [row, col], to: [row + 2*direction, col]});
                    }
                }
                
                for (let dc of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target !== ' ' && this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            getKnightMoves(row, col, color) {
                const moves = [];
                const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target === ' ' || this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            getBishopMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, [[-1,-1],[-1,1],[1,-1],[1,1]]);
            }
            
            getRookMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, [[-1,0],[1,0],[0,-1],[0,1]]);
            }
            
            getQueenMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, 
                    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]);
            }
            
            getSlidingMoves(row, col, color, directions) {
                const moves = [];
                
                for (let [dr, dc] of directions) {
                    let newRow = row + dr;
                    let newCol = col + dc;
                    
                    while (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        
                        if (target === ' ') {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        } else {
                            if (this.getPieceColor(target) !== color) {
                                moves.push({from: [row, col], to: [newRow, newCol]});
                            }
                            break;
                        }
                        
                        newRow += dr;
                        newCol += dc;
                    }
                }
                
                return moves;
            }
            
            getKingMoves(row, col, color) {
                const moves = [];
                const offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target === ' ' || this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            wouldBeInCheck(move, color) {
                const tempBoard = this.board.map(row => [...row]);
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                this.board[toRow][toCol] = this.board[fromRow][fromCol];
                this.board[fromRow][fromCol] = ' ';
                
                const inCheck = this.isInCheck(color);
                
                this.board = tempBoard;
                return inCheck;
            }
            
            isInCheck(color) {
                let kingPos = null;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece.toLowerCase() === 'k' && this.getPieceColor(piece) === color) {
                            kingPos = [row, col];
                            break;
                        }
                    }
                    if (kingPos) break;
                }
                
                if (!kingPos) return false;
                
                const opponentColor = color === 'white' ? 'black' : 'white';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (this.getPieceColor(piece) === opponentColor) {
                            const moves = this.getRawMoves(row, col);
                            for (let move of moves) {
                                if (move.to[0] === kingPos[0] && move.to[1] === kingPos[1]) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            getRawMoves(row, col) {
                const piece = this.board[row][col].toLowerCase();
                const color = this.getPieceColor(this.board[row][col]);
                
                if (!color) return [];
                
                switch(piece) {
                    case 'p': return this.getPawnMoves(row, col, color);
                    case 'n': return this.getKnightMoves(row, col, color);
                    case 'b': return this.getBishopMoves(row, col, color);
                    case 'r': return this.getRookMoves(row, col, color);
                    case 'q': return this.getQueenMoves(row, col, color);
                    case 'k': return this.getKingMoves(row, col, color);
                    default: return [];
                }
            }
            
            makeMove(move) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                const capturedPiece = this.board[toRow][toCol];
                const movingPiece = this.board[fromRow][fromCol];
                
                this.board[toRow][toCol] = movingPiece;
                this.board[fromRow][fromCol] = ' ';
                
                if (movingPiece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                    this.board[toRow][toCol] = this.currentPlayer === 'white' ? 'Q' : 'q';
                }
                
                this.moveHistory.push({
                    move: move,
                    piece: movingPiece,
                    captured: capturedPiece
                });
                
                if (capturedPiece !== ' ' || movingPiece.toLowerCase() === 'p') {
                    this.halfMoveClock = 0;
                } else {
                    this.halfMoveClock++;
                }
                
                if (this.currentPlayer === 'black') {
                    this.fullMoveNumber++;
                }
                
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                return true;
            }
            
            isCheckmate() {
                if (!this.isInCheck(this.currentPlayer)) return false;
                return this.getAllMoves(this.currentPlayer).length === 0;
            }
            
            isStalemate() {
                if (this.isInCheck(this.currentPlayer)) return false;
                return this.getAllMoves(this.currentPlayer).length === 0;
            }
            
            isDraw() {
                if (this.halfMoveClock >= 100) return true;
                
                const pieces = [];
                for (let row of this.board) {
                    for (let piece of row) {
                        if (piece !== ' ' && piece.toLowerCase() !== 'k') {
                            pieces.push(piece.toLowerCase());
                        }
                    }
                }
                
                if (pieces.length === 0) return true;
                if (pieces.length === 1 && (pieces[0] === 'n' || pieces[0] === 'b')) return true;
                
                return false;
            }
            
            isGameOver() {
                return this.isCheckmate() || this.isStalemate() || this.isDraw();
            }
            
            getGameResult() {
                if (this.isCheckmate()) {
                    return this.currentPlayer === 'white' ? 'black' : 'white';
                }
                if (this.isStalemate() || this.isDraw()) {
                    return 'draw';
                }
                return null;
            }
        }
        
        // ============================================
        // AI ENGINE with Learning
        // ============================================
        
        class ChessAI {
            constructor(color) {
                this.color = color;
                this.heuristics = this.loadHeuristics();
                this.searchDepth = 3;
            }
            
            loadHeuristics() {
                try {
                    const saved = localStorage.getItem(`heuristics_${this.color}`);
                    if (saved) {
                        return JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Error loading heuristics:', e);
                }
                
                return {
                    pieceValues: {
                        'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000
                    },
                    positionBonus: 10,
                    mobilityWeight: 5,
                    aggressionFactor: 1.0,
                    resignThreshold: -1500
                };
            }
            
            saveHeuristics() {
                try {
                    localStorage.setItem(`heuristics_${this.color}`, JSON.stringify(this.heuristics));
                } catch (e) {
                    console.error('Error saving heuristics:', e);
                }
            }
            
            updateFromGameResult(result) {
                if (result === this.color) {
                    this.heuristics.aggressionFactor *= 1.01;
                    this.heuristics.mobilityWeight += 0.3;
                } else if (result !== 'draw' && result !== 'resign') {
                    this.heuristics.aggressionFactor *= 0.99;
                }
                
                if (result === 'resign') {
                    this.heuristics.resignThreshold -= 30;
                }
                
                this.saveHeuristics();
            }
            
            evaluatePosition(engine) {
                let score = 0;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = engine.board[row][col];
                        if (piece === ' ') continue;
                        
                        const pieceColor = engine.getPieceColor(piece);
                        const pieceValue = this.heuristics.pieceValues[piece.toLowerCase()];
                        const multiplier = pieceColor === this.color ? 1 : -1;
                        
                        score += pieceValue * multiplier;
                        
                        const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);
                        score += (7 - centerDistance) * this.heuristics.positionBonus * multiplier;
                    }
                }
                
                const myMoves = engine.getAllMoves(this.color).length;
                const opponentColor = this.color === 'white' ? 'black' : 'white';
                const opponentMoves = engine.getAllMoves(opponentColor).length;
                score += (myMoves - opponentMoves) * this.heuristics.mobilityWeight;
                
                if (engine.isInCheck(this.color)) {
                    score -= 50;
                } else if (engine.isInCheck(opponentColor)) {
                    score += 50;
                }
                
                return score * this.heuristics.aggressionFactor;
            }
            
            minimax(engine, depth, alpha, beta, maximizingPlayer) {
                if (depth === 0 || engine.isGameOver()) {
                    return this.evaluatePosition(engine);
                }
                
                const moves = engine.getAllMoves(engine.currentPlayer);
                
                if (moves.length === 0) {
                    if (engine.isInCheck(engine.currentPlayer)) {
                        return maximizingPlayer ? -99999 : 99999;
                    }
                    return 0;
                }
                
                if (maximizingPlayer) {
                    let maxEval = -Infinity;
                    for (let move of moves) {
                        const saveState = this.saveEngineState(engine);
                        engine.makeMove(move);
                        const evaluation = this.minimax(engine, depth - 1, alpha, beta, false);
                        this.restoreEngineState(engine, saveState);
                        
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        if (beta <= alpha) break;
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (let move of moves) {
                        const saveState = this.saveEngineState(engine);
                        engine.makeMove(move);
                        const evaluation = this.minimax(engine, depth - 1, alpha, beta, true);
                        this.restoreEngineState(engine, saveState);
                        
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            }
            
            saveEngineState(engine) {
                return {
                    board: engine.board.map(row => [...row]),
                    currentPlayer: engine.currentPlayer,
                    moveHistory: [...engine.moveHistory],
                    halfMoveClock: engine.halfMoveClock,
                    fullMoveNumber: engine.fullMoveNumber
                };
            }
            
            restoreEngineState(engine, state) {
                engine.board = state.board;
                engine.currentPlayer = state.currentPlayer;
                engine.moveHistory = state.moveHistory;
                engine.halfMoveClock = state.halfMoveClock;
                engine.fullMoveNumber = state.fullMoveNumber;
            }
            
            getBestMove(engine) {
                const moves = engine.getAllMoves(this.color);
                
                if (moves.length === 0) return null;
                
                const currentEval = this.evaluatePosition(engine);
                if (currentEval < this.heuristics.resignThreshold) {
                    return 'resign';
                }
                
                let bestMove = null;
                let bestValue = -Infinity;
                
                for (let move of moves) {
                    const saveState = this.saveEngineState(engine);
                    engine.makeMove(move);
                    const moveValue = this.minimax(engine, this.searchDepth - 1, -Infinity, Infinity, false);
                    this.restoreEngineState(engine, saveState);
                    
                    if (moveValue > bestValue) {
                        bestValue = moveValue;
                        bestMove = move;
                    }
                }
                
                return bestMove;
            }
        }
        
        // ============================================
        // GAME CONTROLLER & UI
        // ============================================
        
        class GameController {
            constructor() {
                this.engine = new ChessEngine();
                this.whiteAI = new ChessAI('white');
                this.blackAI = new ChessAI('black');
                this.stats = this.loadStats();
                this.matchStartTime = Date.now();
                this.totalStartTime = this.stats.totalStartTime || Date.now();
                this.lastMove = null;
                this.lastMoveTime = 0;
                
                this.initBoard();
                this.updateUI();
                this.startGame();
            }
            
            loadStats() {
                try {
                    const saved = localStorage.getItem('chessStats');
                    if (saved) {
                        return JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Error loading stats:', e);
                }
                
                return {
                    totalMatches: 0,
                    whiteWins: 0,
                    blackWins: 0,
                    draws: 0,
                    totalStartTime: Date.now(),
                    matches: []
                };
            }
            
            saveStats() {
                try {
                    localStorage.setItem('chessStats', JSON.stringify(this.stats));
                } catch (e) {
                    console.error('Error saving stats:', e);
                }
            }
            
            initBoard() {
                const board = document.getElementById('chessboard');
                board.innerHTML = '';
                
                const pieces = {
                    'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
                    'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
                };
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.id = `sq-${row}-${col}`;
                        
                        const piece = this.engine.board[row][col];
                        if (piece !== ' ') {
                            square.textContent = pieces[piece];
                        }
                        
                        board.appendChild(square);
                    }
                }
            }
            
            updateBoard() {
                const pieces = {
                    'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
                    'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
                };
                
                document.querySelectorAll('.square').forEach(sq => {
                    sq.classList.remove('last-move');
                });
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.getElementById(`sq-${row}-${col}`);
                        const piece = this.engine.board[row][col];
                        square.textContent = piece !== ' ' ? pieces[piece] : '';
                    }
                }
                
                if (this.lastMove) {
                    const [fromRow, fromCol] = this.lastMove.from;
                    const [toRow, toCol] = this.lastMove.to;
                    const fromSq = document.getElementById(`sq-${fromRow}-${fromCol}`);
                    const toSq = document.getElementById(`sq-${toRow}-${toCol}`);
                    if (fromSq) fromSq.classList.add('last-move');
                    if (toSq) toSq.classList.add('last-move');
                }
            }
            
            updateUI() {
                document.getElementById('totalMatches').textContent = this.stats.totalMatches;
                document.getElementById('whiteWins').textContent = this.stats.whiteWins;
                document.getElementById('blackWins').textContent = this.stats.blackWins;
                document.getElementById('draws').textContent = this.stats.draws;
                
                const matchElapsed = Math.floor((Date.now() - this.matchStartTime) / 1000);
                document.getElementById('matchTime').textContent = `${matchElapsed}s`;
                
                const totalElapsed = Math.floor((Date.now() - this.totalStartTime) / 1000);
                const hours = Math.floor(totalElapsed / 3600);
                const minutes = Math.floor((totalElapsed % 3600) / 60);
                const seconds = totalElapsed % 60;
                document.getElementById('totalTime').textContent = 
                    hours > 0 ? `${hours}h ${minutes}m` : 
                    minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                
                if (this.lastMoveTime > 0) {
                    document.getElementById('moveTime').textContent = 
                        `Last move: ${this.lastMoveTime}ms`;
                }
            }
            
            async startGame() {
                while (true) {
                    await this.playGame();
                    await this.delay(2000);
                }
            }
            
            async playGame() {
                this.engine = new ChessEngine();
                this.matchStartTime = Date.now();
                this.lastMove = null;
                this.initBoard();
                
                const moveTimes = [];
                let resigned = false;
                let resignedBy = null;
                
                while (!this.engine.isGameOver() && !resigned) {
                    const currentAI = this.engine.currentPlayer === 'white' ? this.whiteAI : this.blackAI;
                    const aiName = this.engine.currentPlayer === 'white' ? 'WhiteAI' : 'BlackAI';
                    
                    document.getElementById('status').textContent = `${aiName} thinking...`;
                    this.updateUI();
                    
                    await this.delay(100);
                    
                    const moveStart = Date.now();
                    const move = currentAI.getBestMove(this.engine);
                    const moveTime = Date.now() - moveStart;
                    
                    this.lastMoveTime = moveTime;
                    moveTimes.push(moveTime);
                    
                    if (move === 'resign') {
                        resigned = true;
                        resignedBy = this.engine.currentPlayer;
                        document.getElementById('status').textContent = `${aiName} resigned!`;
                        break;
                    }
                    
                    if (!move) break;
                    
                    this.lastMove = move;
                    this.engine.makeMove(move);
                    this.updateBoard();
                    this.updateUI();
                    
                    await this.delay(50);
                }
                
                let result;
                if (resigned) {
                    result = resignedBy === 'white' ? 'black' : 'white';
                    document.getElementById('status').textContent = 
                        `${resignedBy === 'white' ? 'BlackAI' : 'WhiteAI'} wins by resignation!`;
                } else if (this.engine.isCheckmate()) {
                    result = this.engine.getGameResult();
                    document.getElementById('status').textContent = 
                        `Checkmate! ${result === 'white' ? 'WhiteAI' : 'BlackAI'} wins!`;
                } else if (this.engine.isStalemate()) {
                    result = 'draw';
                    document.getElementById('status').textContent = 'Stalemate! Draw.';
                } else if (this.engine.isDraw()) {
                    result = 'draw';
                    document.getElementById('status').textContent = 'Draw by rules.';
                } else {
                    result = 'draw';
                    document.getElementById('status').textContent = 'Game ended.';
                }
                
                this.stats.totalMatches++;
                if (result === 'white') {
                    this.stats.whiteWins++;
                } else if (result === 'black') {
                    this.stats.blackWins++;
                } else {
                    this.stats.draws++;
                }
                
                const matchData = {
                    matchNumber: this.stats.totalMatches,
                    result: result,
                    moves: this.engine.moveHistory.length,
                    duration: Date.now() - this.matchStartTime,
                    avgMoveTime: moveTimes.length > 0 ? moveTimes.reduce((a, b) => a + b, 0) / moveTimes.length : 0,
                    resigned: resigned,
                    timestamp: new Date().toISOString()
                };
                
                this.stats.matches.push(matchData);
                
                if (this.stats.matches.length > 100) {
                    this.stats.matches.shift();
                }
                
                this.saveStats();
                
                this.whiteAI.updateFromGameResult(result);
                this.blackAI.updateFromGameResult(result);
                
                this.updateUI();
                
                this.savePGN(matchData);
            }
            
            savePGN(matchData) {
                try {
                    const pgn = this.generatePGN(matchData);
                    const pgnHistory = JSON.parse(localStorage.getItem('pgnHistory') || '[]');
                    pgnHistory.push(pgn);
                    
                    if (pgnHistory.length > 50) {
                        pgnHistory.shift();
                    }
                    
                    localStorage.setItem('pgnHistory', JSON.stringify(pgnHistory));
                } catch (e) {
                    console.error('Error saving PGN:', e);
                }
            }
            
            generatePGN(matchData) {
                let pgn = `[Event "AI Battle"]\n`;
                pgn += `[Date "${new Date().toISOString().split('T')[0]}"]\n`;
                pgn += `[White "WhiteAI"]\n`;
                pgn += `[Black "BlackAI"]\n`;
                pgn += `[Result "${matchData.result === 'white' ? '1-0' : matchData.result === 'black' ? '0-1' : '1/2-1/2'}"]\n\n`;
                
                const moves = this.engine.moveHistory;
                let moveText = '';
                
                for (let i = 0; i < moves.length; i++) {
                    if (i % 2 === 0) {
                        moveText += `${Math.floor(i / 2) + 1}. `;
                    }
                    
                    const move = moves[i].move;
                    const [fromRow, fromCol] = move.from;
                    const [toRow, toCol] = move.to;
                    const piece = moves[i].piece;
                    
                    const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                    const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                    
                    moveText += `${piece.toUpperCase() === 'P' ? '' : piece.toUpperCase()}${fromSquare}${toSquare} `;
                }
                
                pgn += moveText;
                pgn += `\n${matchData.result === 'white' ? '1-0' : matchData.result === 'black' ? '0-1' : '1/2-1/2'}`;
                
                return pgn;
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // ============================================
        // START APPLICATION
        // ============================================
        
        let game;
        
        window.addEventListener('DOMContentLoaded', () => {
            try {
                game = new GameController();
                
                setInterval(() => {
                    if (game) {
                        game.updateUI();
                    }
                }, 1000);
            } catch (e) {
                console.error('Error starting game:', e);
                document.getElementById('status').textContent = 'Error: ' + e.message;
            }
        });
    </script>
</body>
</html>
