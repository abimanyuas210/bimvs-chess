<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess AI Battle Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
            padding: 30px;
            max-width: 900px;
            width: 100%;
            position: relative;
            overflow: hidden;
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(102,126,234,0.1) 0%, rgba(118,75,162,0.05) 100%);
            z-index: 0;
        }
        
        h1 {
            text-align: center;
            color: #2d3436;
            margin-bottom: 25px;
            font-size: 2.2rem;
            position: relative;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        h1::after {
            content: '';
            display: block;
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            margin: 10px auto;
            border-radius: 2px;
        }
        
        .header-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }
        
        .control-panel {
            display: flex;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102,126,234,0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102,126,234,0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .match-info {
            background: #f8f9fa;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            position: relative;
            z-index: 1;
        }
        
        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 4px solid #2d3436;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(2rem, 5vw, 3rem);
            cursor: default;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .square.light {
            background-color: #f0d9b5;
        }
        
        .square.dark {
            background-color: #b58863;
        }
        
        .square.last-move {
            background-color: rgba(255, 255, 100, 0.6) !important;
        }
        
        .square:hover {
            filter: brightness(1.1);
        }
        
        .coord {
            position: absolute;
            font-size: 0.7rem;
            font-weight: bold;
            color: rgba(0,0,0,0.7);
        }
        
        .coord.file {
            bottom: 2px;
            right: 4px;
        }
        
        .coord.rank {
            top: 2px;
            left: 4px;
        }
        
        .square.dark .coord {
            color: rgba(255,255,255,0.9);
        }
        
        .status-panel {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .status {
            font-size: 1.3rem;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        .move-time {
            font-size: 1rem;
            color: #636e72;
            text-align: center;
            margin-top: 5px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 10px;
            position: relative;
            z-index: 1;
        }
        
        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .stat-box:hover {
            transform: translateY(-5px);
            border-color: #667eea;
            box-shadow: 0 8px 20px rgba(102,126,234,0.2);
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2d3436;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        
        .ai-info {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            position: relative;
            z-index: 1;
        }
        
        .ai-box {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 45%;
        }
        
        .ai-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #2d3436;
            margin-bottom: 8px;
        }
        
        .ai-stats {
            font-size: 0.9rem;
            color: #666;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 1.6rem;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .ai-info {
                flex-direction: column;
                gap: 10px;
            }
            
            .ai-box {
                width: 100%;
            }
            
            .header-info {
                flex-direction: column;
                gap: 15px;
            }
            
            .control-panel {
                width: 100%;
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }
            
            .stat-value {
                font-size: 1.4rem;
            }
            
            .square {
                font-size: 1.8rem;
            }
        }
        
        .captured-pieces {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            min-height: 40px;
        }
        
        .captured-piece {
            font-size: 1.2rem;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ôî Chess AI Battle Arena ‚ôö</h1>
        
        <div class="header-info">
            <div class="match-info">
                Match #<span id="matchNumber">1</span>
            </div>
            <div class="control-panel">
                <button onclick="togglePause()" id="pauseBtn">‚è∏Ô∏è Pause</button>
                <button onclick="resetStats()">üîÑ Reset Stats</button>
                <button onclick="newGame()">üÜï New Game</button>
            </div>
        </div>
        
        <div class="status-panel">
            <div class="status" id="status">Initializing AI Battle...</div>
            <div class="move-time" id="moveTime"></div>
        </div>
        
        <div class="ai-info">
            <div class="ai-box" style="border-left: 5px solid #667eea;">
                <div class="ai-name">ü§ñ White AI</div>
                <div class="ai-stats">
                    Wins: <span id="whiteWinsCount">0</span> | 
                    Learning: <span id="whiteLearning">0%</span>
                </div>
            </div>
            <div class="ai-box" style="border-left: 5px solid #2d3436;">
                <div class="ai-name">ü§ñ Black AI</div>
                <div class="ai-stats">
                    Wins: <span id="blackWinsCount">0</span> | 
                    Learning: <span id="blackLearning">0%</span>
                </div>
            </div>
        </div>
        
        <div class="board-container">
            <div class="chessboard" id="chessboard"></div>
        </div>
        
        <div class="captured-pieces">
            <div id="capturedWhite"></div>
            <div id="capturedBlack"></div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">Total Matches</div>
                <div class="stat-value" id="totalMatches">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">White AI Wins</div>
                <div class="stat-value" id="whiteWins">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Black AI Wins</div>
                <div class="stat-value" id="blackWins">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Draws</div>
                <div class="stat-value" id="draws">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Current Move</div>
                <div class="stat-value" id="moveCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Match Time</div>
                <div class="stat-value" id="matchTime">0s</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Total Time</div>
                <div class="stat-value" id="totalTime">0s</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">AI Level</div>
                <div class="stat-value" id="aiLevel">3</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // LOCAL STORAGE MANAGER
        // ============================================
        
        class StorageManager {
            static save(key, data) {
                try {
                    localStorage.setItem(`chess_ai_${key}`, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.error('Error saving to localStorage:', e);
                    return false;
                }
            }
            
            static load(key, defaultValue = null) {
                try {
                    const data = localStorage.getItem(`chess_ai_${key}`);
                    return data ? JSON.parse(data) : defaultValue;
                } catch (e) {
                    console.error('Error loading from localStorage:', e);
                    return defaultValue;
                }
            }
            
            static clear() {
                const keys = Object.keys(localStorage).filter(key => key.startsWith('chess_ai_'));
                keys.forEach(key => localStorage.removeItem(key));
            }
        }
        
        // ============================================
        // GAME STATISTICS
        // ============================================
        
        class GameStats {
            constructor() {
                this.totalMatches = 0;
                this.whiteWins = 0;
                this.blackWins = 0;
                this.draws = 0;
                this.totalTime = 0;
                this.aiLevel = 3;
                this.matchHistory = [];
                this.load();
            }
            
            load() {
                const saved = StorageManager.load('stats');
                if (saved) {
                    Object.assign(this, saved);
                    console.log('Statistics loaded:', saved);
                }
            }
            
            save() {
                StorageManager.save('stats', {
                    totalMatches: this.totalMatches,
                    whiteWins: this.whiteWins,
                    blackWins: this.blackWins,
                    draws: this.draws,
                    totalTime: this.totalTime,
                    aiLevel: this.aiLevel,
                    matchHistory: this.matchHistory.slice(-50) // Keep last 50 matches
                });
            }
            
            recordResult(result, duration) {
                this.totalMatches++;
                this.totalTime += duration;
                
                if (result === 'white') {
                    this.whiteWins++;
                } else if (result === 'black') {
                    this.blackWins++;
                } else {
                    this.draws++;
                }
                
                this.matchHistory.push({
                    result: result,
                    duration: duration,
                    timestamp: Date.now(),
                    moveCount: currentMoveCount
                });
                
                this.save();
                updateStatsDisplay();
            }
            
            reset() {
                this.totalMatches = 0;
                this.whiteWins = 0;
                this.blackWins = 0;
                this.draws = 0;
                this.totalTime = 0;
                this.matchHistory = [];
                this.save();
                updateStatsDisplay();
            }
        }
        
        // ============================================
        // CHESS ENGINE (Tetap sama)
        // ============================================
        
        class ChessEngine {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.moveHistory = [];
                this.halfMoveClock = 0;
                this.fullMoveNumber = 1;
                this.capturedPieces = { white: [], black: [] };
            }
            
            createInitialBoard() {
                return [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    [' ',' ',' ',' ',' ',' ',' ',' '],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
            }
            
            isValidSquare(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            getPieceColor(piece) {
                if (piece === ' ') return null;
                return piece === piece.toUpperCase() ? 'white' : 'black';
            }
            
            getAllMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (this.getPieceColor(piece) === color) {
                            const pieceMoves = this.getPieceMoves(row, col);
                            moves.push(...pieceMoves);
                        }
                    }
                }
                return moves;
            }
            
            getPieceMoves(row, col) {
                const piece = this.board[row][col].toLowerCase();
                const color = this.getPieceColor(this.board[row][col]);
                
                if (!color) return [];
                
                let moves = [];
                
                switch(piece) {
                    case 'p': moves = this.getPawnMoves(row, col, color); break;
                    case 'n': moves = this.getKnightMoves(row, col, color); break;
                    case 'b': moves = this.getBishopMoves(row, col, color); break;
                    case 'r': moves = this.getRookMoves(row, col, color); break;
                    case 'q': moves = this.getQueenMoves(row, col, color); break;
                    case 'k': moves = this.getKingMoves(row, col, color); break;
                }
                
                return moves.filter(move => !this.wouldBeInCheck(move, color));
            }
            
            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                
                if (this.isValidSquare(row + direction, col) && 
                    this.board[row + direction][col] === ' ') {
                    moves.push({from: [row, col], to: [row + direction, col]});
                    
                    if (row === startRow && this.board[row + 2*direction][col] === ' ') {
                        moves.push({from: [row, col], to: [row + 2*direction, col]});
                    }
                }
                
                for (let dc of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target !== ' ' && this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            getKnightMoves(row, col, color) {
                const moves = [];
                const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target === ' ' || this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            getBishopMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, [[-1,-1],[-1,1],[1,-1],[1,1]]);
            }
            
            getRookMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, [[-1,0],[1,0],[0,-1],[0,1]]);
            }
            
            getQueenMoves(row, col, color) {
                return this.getSlidingMoves(row, col, color, 
                    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]);
            }
            
            getSlidingMoves(row, col, color, directions) {
                const moves = [];
                
                for (let [dr, dc] of directions) {
                    let newRow = row + dr;
                    let newCol = col + dc;
                    
                    while (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        
                        if (target === ' ') {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        } else {
                            if (this.getPieceColor(target) !== color) {
                                moves.push({from: [row, col], to: [newRow, newCol]});
                            }
                            break;
                        }
                        
                        newRow += dr;
                        newCol += dc;
                    }
                }
                
                return moves;
            }
            
            getKingMoves(row, col, color) {
                const moves = [];
                const offsets = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                
                for (let [dr, dc] of offsets) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isValidSquare(newRow, newCol)) {
                        const target = this.board[newRow][newCol];
                        if (target === ' ' || this.getPieceColor(target) !== color) {
                            moves.push({from: [row, col], to: [newRow, newCol]});
                        }
                    }
                }
                
                return moves;
            }
            
            wouldBeInCheck(move, color) {
                const tempBoard = this.board.map(row => [...row]);
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                this.board[toRow][toCol] = this.board[fromRow][fromCol];
                this.board[fromRow][fromCol] = ' ';
                
                const inCheck = this.isInCheck(color);
                
                this.board = tempBoard;
                return inCheck;
            }
            
            isInCheck(color) {
                let kingPos = null;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece.toLowerCase() === 'k' && this.getPieceColor(piece) === color) {
                            kingPos = [row, col];
                            break;
                        }
                    }
                    if (kingPos) break;
                }
                
                if (!kingPos) return false;
                
                const opponentColor = color === 'white' ? 'black' : 'white';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (this.getPieceColor(piece) === opponentColor) {
                            const moves = this.getRawMoves(row, col);
                            for (let move of moves) {
                                if (move.to[0] === kingPos[0] && move.to[1] === kingPos[1]) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            getRawMoves(row, col) {
                const piece = this.board[row][col].toLowerCase();
                const color = this.getPieceColor(this.board[row][col]);
                
                if (!color) return [];
                
                switch(piece) {
                    case 'p': return this.getPawnMoves(row, col, color);
                    case 'n': return this.getKnightMoves(row, col, color);
                    case 'b': return this.getBishopMoves(row, col, color);
                    case 'r': return this.getRookMoves(row, col, color);
                    case 'q': return this.getQueenMoves(row, col, color);
                    case 'k': return this.getKingMoves(row, col, color);
                    default: return [];
                }
            }
            
            makeMove(move) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                
                const capturedPiece = this.board[toRow][toCol];
                const movingPiece = this.board[fromRow][fromCol];
                
                if (capturedPiece !== ' ') {
                    const capturedColor = this.getPieceColor(capturedPiece);
                    const oppositeColor = capturedColor === 'white' ? 'black' : 'white';
                    this.capturedPieces[oppositeColor].push(capturedPiece);
                }
                
                this.board[toRow][toCol] = movingPiece;
                this.board[fromRow][fromCol] = ' ';
                
                if (movingPiece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                    this.board[toRow][toCol] = this.currentPlayer === 'white' ? 'Q' : 'q';
                }
                
                this.moveHistory.push({
                    move: move,
                    piece: movingPiece,
                    captured: capturedPiece,
                    moveNumber: this.fullMoveNumber,
                    player: this.currentPlayer
                });
                
                if (capturedPiece !== ' ' || movingPiece.toLowerCase() === 'p') {
                    this.halfMoveClock = 0;
                } else {
                    this.halfMoveClock++;
                }
                
                if (this.currentPlayer === 'black') {
                    this.fullMoveNumber++;
                }
                
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                return true;
            }
            
            isCheckmate() {
                if (!this.isInCheck(this.currentPlayer)) return false;
                return this.getAllMoves(this.currentPlayer).length === 0;
            }
            
            isStalemate() {
                if (this.isInCheck(this.currentPlayer)) return false;
                return this.getAllMoves(this.currentPlayer).length === 0;
            }
            
            isDraw() {
                if (this.halfMoveClock >= 100) return true;
                
                const pieces = [];
                for (let row of this.board) {
                    for (let piece of row) {
                        if (piece !== ' ' && piece.toLowerCase() !== 'k') {
                            pieces.push(piece.toLowerCase());
                        }
                    }
                }
                
                if (pieces.length === 0) return true;
                if (pieces.length === 1 && (pieces[0] === 'n' || pieces[0] === 'b')) return true;
                
                return false;
            }
            
            isGameOver() {
                return this.isCheckmate() || this.isStalemate() || this.isDraw();
            }
            
            getGameResult() {
                if (this.isCheckmate()) {
                    return this.currentPlayer === 'white' ? 'black' : 'white';
                }
                if (this.isStalemate() || this.isDraw()) {
                    return 'draw';
                }
                return null;
            }
        }
        
        // ============================================
        // AI ENGINE with Learning
        // ============================================
        
        class ChessAI {
            constructor(color) {
                this.color = color;
                this.heuristics = this.loadHeuristics();
                this.searchDepth = gameStats.aiLevel;
                this.learningRate = 0.1;
                this.experience = 0;
            }
            
            loadHeuristics() {
                const saved = StorageManager.load(`ai_${this.color}`, null);
                if (saved) {
                    console.log(`Loaded AI ${this.color} heuristics:`, saved);
                    return saved;
                }
                
                return {
                    pieceValues: {
                        'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000
                    },
                    positionBonus: 10,
                    mobilityWeight: 5,
                    aggressionFactor: 1.0,
                    resignThreshold: -1500,
                    experience: 0
                };
            }
            
            saveHeuristics() {
                this.heuristics.experience = this.experience;
                StorageManager.save(`ai_${this.color}`, this.heuristics);
            }
            
            updateFromGameResult(result) {
                this.experience++;
                
                if (result === this.color) {
                    // Win - increase aggression
                    this.heuristics.aggressionFactor = Math.min(
                        1.5, 
                        this.heuristics.aggressionFactor * 1.02
                    );
                    this.heuristics.mobilityWeight += 0.2;
                } else if (result !== 'draw') {
                    // Loss - adjust strategy
                    this.heuristics.aggressionFactor = Math.max(
                        0.7, 
                        this.heuristics.aggressionFactor * 0.98
                    );
                }
                
                if (this.experience % 10 === 0) {
                    // Every 10 games, increase search depth if winning
                    const winRate = this.getWinRate();
                    if (winRate > 0.6 && this.searchDepth < 5) {
                        this.searchDepth++;
                    }
                }
                
                this.saveHeuristics();
            }
            
            getWinRate() {
                const totalGames = gameStats.totalMatches;
                if (totalGames === 0) return 0;
                
                const wins = this.color === 'white' ? gameStats.whiteWins : gameStats.blackWins;
                return wins / totalGames;
            }
            
            evaluatePosition(engine) {
                let score = 0;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = engine.board[row][col];
                        if (piece !== ' ') {
                            const pieceValue = this.heuristics.pieceValues[piece.toLowerCase()];
                            const color = engine.getPieceColor(piece);
                            
                            if (color === this.color) {
                                score += pieceValue;
                                score += this.getPositionBonus(piece.toLowerCase(), row, col);
                            } else {
                                score -= pieceValue;
                                score -= this.getPositionBonus(piece.toLowerCase(), row, col);
                            }
                        }
                    }
                }
                
                const mobility = engine.getAllMoves(this.color).length;
                const opponentMobility = engine.getAllMoves(this.color === 'white' ? 'black' : 'white').length;
                
                score += (mobility - opponentMobility) * this.heuristics.mobilityWeight;
                
                if (engine.isInCheck(this.color)) {
                    score -= 50;
                }
                if (engine.isInCheck(this.color === 'white' ? 'black' : 'white')) {
                    score += 50;
                }
                
                return score * this.heuristics.aggressionFactor;
            }
            
            getPositionBonus(piece, row, col) {
                const positionTable = {
                    'p': [
                        [0,0,0,0,0,0,0,0],
                        [50,50,50,50,50,50,50,50],
                        [10,10,20,30,30,20,10,10],
                        [5,5,10,25,25,10,5,5],
                        [0,0,0,20,20,0,0,0],
                        [5,-5,-10,0,0,-10,-5,5],
                        [5,10,10,-20,-20,10,10,5],
                        [0,0,0,0,0,0,0,0]
                    ],
                    'n': [
                        [-50,-40,-30,-30,-30,-30,-40,-50],
                        [-40,-20,0,0,0,0,-20,-40],
                        [-30,0,10,15,15,10,0,-30],
                        [-30,5,15,20,20,15,5,-30],
                        [-30,0,15,20,20,15,0,-30],
                        [-30,5,10,15,15,10,5,-30],
                        [-40,-20,0,5,5,0,-20,-40],
                        [-50,-40,-30,-30,-30,-30,-40,-50]
                    ]
                };
                
                const table = positionTable[piece];
                if (!table) return 0;
                
                const adjustedRow = this.color === 'white' ? 7 - row : row;
                return table[adjustedRow][col] || 0;
            }
            
            minimax(engine, depth, alpha, beta, maximizingPlayer) {
                if (depth === 0 || engine.isGameOver()) {
                    return { score: this.evaluatePosition(engine) };
                }
                
                if (maximizingPlayer) {
                    let maxEval = -Infinity;
                    let bestMove = null;
                    
                    const moves = engine.getAllMoves(this.color);
                    moves.sort(() => Math.random() - 0.5);
                    
                    for (const move of moves) {
                        const tempEngine = this.cloneEngine(engine);
                        tempEngine.makeMove(move);
                        
                        const evaluation = this.minimax(tempEngine, depth - 1, alpha, beta, false);
                        
                        if (evaluation.score > maxEval) {
                            maxEval = evaluation.score;
                            bestMove = move;
                        }
                        
                        alpha = Math.max(alpha, evaluation.score);
                        if (beta <= alpha) {
                            break;
                        }
                    }
                    
                    return { score: maxEval, move: bestMove };
                } else {
                    let minEval = Infinity;
                    let bestMove = null;
                    
                    const opponentColor = this.color === 'white' ? 'black' : 'white';
                    const moves = engine.getAllMoves(opponentColor);
                    moves.sort(() => Math.random() - 0.5);
                    
                    for (const move of moves) {
                        const tempEngine = this.cloneEngine(engine);
                        tempEngine.makeMove(move);
                        
                        const evaluation = this.minimax(tempEngine, depth - 1, alpha, beta, true);
                        
                        if (evaluation.score < minEval) {
                            minEval = evaluation.score;
                            bestMove = move;
                        }
                        
                        beta = Math.min(beta, evaluation.score);
                        if (beta <= alpha) {
                            break;
                        }
                    }
                    
                    return { score: minEval, move: bestMove };
                }
            }
            
            cloneEngine(engine) {
                const clone = new ChessEngine();
                clone.board = engine.board.map(row => [...row]);
                clone.currentPlayer = engine.currentPlayer;
                clone.moveHistory = [...engine.moveHistory];
                clone.halfMoveClock = engine.halfMoveClock;
                clone.fullMoveNumber = engine.fullMoveNumber;
                clone.capturedPieces = {
                    white: [...engine.capturedPieces.white],
                    black: [...engine.capturedPieces.black]
                };
                return clone;
            }
            
            getBestMove(engine) {
                const startTime = Date.now();
                
                if (engine.isGameOver()) {
                    return null;
                }
                
                const result = this.minimax(engine, this.searchDepth, -Infinity, Infinity, true);
                
                const evaluation = this.evaluatePosition(engine);
                if (evaluation < this.heuristics.resignThreshold && engine.getAllMoves(this.color).length > 0) {
                    if (Math.random() < 0.3) {
                        return 'resign';
                    }
                }
                
                const moveTime = Date.now() - startTime;
                console.log(`AI ${this.color} move time: ${moveTime}ms, Evaluation: ${result.score.toFixed(2)}`);
                
                return result.move;
            }
            
            getLearningProgress() {
                return Math.min(100, Math.floor((this.experience / 50) * 100));
            }
        }
        
        // ============================================
        // GAME STATE VARIABLES
        // ============================================
        
        let chessEngine = new ChessEngine();
        let whiteAI = new ChessAI('white');
        let blackAI = new ChessAI('black');
        let gameStats = new GameStats();
        let isPaused = false;
        let gameActive = true;
        let lastMoveTime = null;
        let moveStartTime = Date.now();
        let gameStartTime = Date.now();
        let matchStartTime = Date.now();
        let currentMoveCount = 0;
        let lastMove = null;
        let matchNumber = 1;
        
        // ============================================
        // DOM ELEMENTS
        // ============================================
        
        const chessboard = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const moveTimeElement = document.getElementById('moveTime');
        const moveCountElement = document.getElementById('moveCount');
        const matchTimeElement = document.getElementById('matchTime');
        const totalTimeElement = document.getElementById('totalTime');
        const totalMatchesElement = document.getElementById('totalMatches');
        const whiteWinsElement = document.getElementById('whiteWins');
        const blackWinsElement = document.getElementById('blackWins');
        const drawsElement = document.getElementById('draws');
        const aiLevelElement = document.getElementById('aiLevel');
        const whiteWinsCountElement = document.getElementById('whiteWinsCount');
        const blackWinsCountElement = document.getElementById('blackWinsCount');
        const whiteLearningElement = document.getElementById('whiteLearning');
        const blackLearningElement = document.getElementById('blackLearning');
        const matchNumberElement = document.getElementById('matchNumber');
        const capturedWhiteElement = document.getElementById('capturedWhite');
        const capturedBlackElement = document.getElementById('capturedBlack');
        const pauseBtn = document.getElementById('pauseBtn');
        
        // ============================================
        // DISPLAY FUNCTIONS
        // ============================================
        
        function updateStatsDisplay() {
            totalMatchesElement.textContent = gameStats.totalMatches;
            whiteWinsElement.textContent = gameStats.whiteWins;
            blackWinsElement.textContent = gameStats.blackWins;
            drawsElement.textContent = gameStats.draws;
            
            whiteWinsCountElement.textContent = gameStats.whiteWins;
            blackWinsCountElement.textContent = gameStats.blackWins;
            
            aiLevelElement.textContent = gameStats.aiLevel;
            
            whiteLearningElement.textContent = whiteAI.getLearningProgress() + '%';
            blackLearningElement.textContent = blackAI.getLearningProgress() + '%';
            
            matchNumberElement.textContent = gameStats.totalMatches + 1;
        }
        
        function updateTimeDisplay() {
            const matchElapsed = Math.floor((Date.now() - matchStartTime) / 1000);
            matchTimeElement.textContent = `${matchElapsed}s`;
            
            const totalSeconds = gameStats.totalTime + matchElapsed;
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                totalTimeElement.textContent = `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                totalTimeElement.textContent = `${minutes}m ${seconds}s`;
            } else {
                totalTimeElement.textContent = `${seconds}s`;
            }
        }
        
        function updateCapturedPiecesDisplay() {
            capturedWhiteElement.innerHTML = chessEngine.capturedPieces.white
                .map(piece => `<span class="captured-piece">${getPieceSymbol(piece)}</span>`)
                .join('');
            
            capturedBlackElement.innerHTML = chessEngine.capturedPieces.black
                .map(piece => `<span class="captured-piece">${getPieceSymbol(piece)}</span>`)
                .join('');
        }
        
        function renderBoard() {
            chessboard.innerHTML = '';
            
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const isLight = (row + col) % 2 === 0;
                    
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    
                    if (lastMove && (
                        (lastMove.from[0] === row && lastMove.from[1] === col) ||
                        (lastMove.to[0] === row && lastMove.to[1] === col)
                    )) {
                        square.classList.add('last-move');
                    }
                    
                    const piece = chessEngine.board[row][col];
                    if (piece !== ' ') {
                        square.textContent = getPieceSymbol(piece);
                    }
                    
                    if (row === 7) {
                        const fileCoord = document.createElement('div');
                        fileCoord.className = 'coord file';
                        fileCoord.textContent = files[col];
                        square.appendChild(fileCoord);
                    }
                    
                    if (col === 0) {
                        const rankCoord = document.createElement('div');
                        rankCoord.className = 'coord rank';
                        rankCoord.textContent = 8 - row;
                        square.appendChild(rankCoord);
                    }
                    
                    chessboard.appendChild(square);
                }
            }
        }
        
        function getPieceSymbol(piece) {
            const symbols = {
                'p': '‚ôü', 'n': '‚ôû', 'b': '‚ôù', 'r': '‚ôú', 'q': '‚ôõ', 'k': '‚ôö',
                'P': '‚ôô', 'N': '‚ôò', 'B': '‚ôó', 'R': '‚ôñ', 'Q': '‚ôï', 'K': '‚ôî'
            };
            return symbols[piece] || piece;
        }
        
        function updateStatus(message, type = 'info') {
            statusElement.textContent = message;
            statusElement.style.color = type === 'info' ? '#667eea' : 
                                      type === 'success' ? '#00b894' : 
                                      type === 'warning' ? '#fdcb6e' : '#d63031';
        }
        
        // ============================================
        // GAME CONTROL FUNCTIONS
        // ============================================
        
        function togglePause() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            
            if (isPaused) {
                updateStatus('Game Paused', 'warning');
            } else {
                updateStatus(`${chessEngine.currentPlayer === 'white' ? 'White' : 'Black'} AI Thinking...`, 'info');
                setTimeout(processAIMove, 100);
            }
        }
        
        function newGame() {
            chessEngine = new ChessEngine();
            gameActive = true;
            isPaused = false;
            currentMoveCount = 0;
            matchStartTime = Date.now();
            moveStartTime = Date.now();
            lastMove = null;
            
            pauseBtn.textContent = '‚è∏Ô∏è Pause';
            updateStatus('Starting new game...', 'info');
            renderBoard();
            updateCapturedPiecesDisplay();
            
            setTimeout(processAIMove, 500);
        }
        
        function resetStats() {
            if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
                gameStats.reset();
                StorageManager.clear();
                whiteAI = new ChessAI('white');
                blackAI = new ChessAI('black');
                newGame();
            }
        }
        
        function endGame(result) {
            gameActive = false;
            const matchDuration = Math.floor((Date.now() - matchStartTime) / 1000);
            
            gameStats.recordResult(result, matchDuration);
            
            whiteAI.updateFromGameResult(result);
            blackAI.updateFromGameResult(result === 'white' ? 'black' : result === 'black' ? 'white' : result);
            
            let message = '';
            if (result === 'white') {
                message = 'üéâ White AI Wins by Checkmate!';
            } else if (result === 'black') {
                message = 'üéâ Black AI Wins by Checkmate!';
            } else {
                message = 'ü§ù Game Drawn!';
            }
            
            updateStatus(message, result === 'draw' ? 'info' : 'success');
            
            setTimeout(() => {
                if (confirm(`${message}\n\nStart new game?`)) {
                    newGame();
                }
            }, 1000);
        }
        
        async function processAIMove() {
            if (!gameActive || isPaused) return;
            
            const startTime = Date.now();
            let ai;
            
            if (chessEngine.currentPlayer === 'white') {
                ai = whiteAI;
                updateStatus('ü§ñ White AI Thinking...', 'info');
            } else {
                ai = blackAI;
                updateStatus('ü§ñ Black AI Thinking...', 'info');
            }
            
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const move = ai.getBestMove(chessEngine);
            
            if (move === 'resign') {
                const winner = chessEngine.currentPlayer === 'white' ? 'black' : 'white';
                updateStatus(`${winner === 'white' ? 'White' : 'Black'} AI resigns!`, 'warning');
                endGame(winner);
                return;
            }
            
            if (move && !chessEngine.isGameOver()) {
                chessEngine.makeMove(move);
                lastMove = move;
                currentMoveCount++;
                
                moveCountElement.textContent = currentMoveCount;
                
                const moveTime = Date.now() - startTime;
                moveTimeElement.textContent = `Move time: ${moveTime}ms`;
                
                updateCapturedPiecesDisplay();
                renderBoard();
                
                if (chessEngine.isGameOver()) {
                    const result = chessEngine.getGameResult();
                    endGame(result);
                    return;
                }
                
                setTimeout(processAIMove, 300);
            }
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        function init() {
            console.log('Initializing Chess AI Battle Arena...');
            
            updateStatsDisplay();
            renderBoard();
            
            // Load match number from stats
            matchNumber = gameStats.totalMatches + 1;
            matchNumberElement.textContent = matchNumber;
            
            // Start the first game
            setTimeout(() => {
                updateStatus('White AI Thinking...', 'info');
                processAIMove();
            }, 1000);
            
            // Update time display every second
            setInterval(updateTimeDisplay, 1000);
            
            // Auto-save every 30 seconds
            setInterval(() => {
                gameStats.save();
                console.log('Auto-saved game statistics');
            }, 30000);
        }
        
        // ============================================
        // START THE GAME
        // ============================================
        
        window.addEventListener('load', init);
        window.addEventListener('beforeunload', () => {
            gameStats.save();
        });
    </script>
</body>
</html>
